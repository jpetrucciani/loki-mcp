#![allow(dead_code)]

use anyhow::{Result, bail};
use serde_json::{Value, json};

use crate::loki::client::LokiClient;

pub async fn check_health(client: &LokiClient) -> Result<Value> {
    let health = client.check_health().await?;

    Ok(json!({
        "healthy": health.healthy,
        "message": health.message,
        "build_info": health.build_info,
        "ring_status": health.ring_status,
    }))
}

pub fn explain_query(query: &str) -> Result<Value> {
    let trimmed = query.trim();
    if trimmed.is_empty() {
        bail!("query must not be empty");
    }

    let selector = extract_selector(trimmed);
    let pipeline_stages = extract_pipeline_stages(trimmed);
    let aggregation = extract_aggregation(trimmed);

    Ok(json!({
        "query": trimmed,
        "selector": selector,
        "pipeline_stages": pipeline_stages,
        "aggregation": aggregation,
    }))
}

pub fn suggest_metric_rule(
    query: &str,
    metric_name: &str,
    description: Option<&str>,
    rule_type: Option<&str>,
    alert_threshold: Option<f64>,
    alert_for: Option<&str>,
) -> Result<Value> {
    let query = query.trim();
    if query.is_empty() {
        bail!("query must not be empty");
    }

    let metric_name = metric_name.trim();
    if metric_name.is_empty() {
        bail!("metric_name must not be empty");
    }

    let rule_type = rule_type.unwrap_or("recording");
    let description = description.unwrap_or("Generated by loki-mcp");

    let yaml = if rule_type == "alerting" {
        let threshold = alert_threshold.unwrap_or(1.0);
        let alert_for = alert_for.unwrap_or("5m");

        format!(
            "groups:\n  - name: loki-mcp-generated\n    rules:\n      - alert: {metric_name}_alert\n        expr: {query} > {threshold}\n        for: {alert_for}\n        annotations:\n          summary: \"{description}\"\n"
        )
    } else {
        format!(
            "groups:\n  - name: loki-mcp-generated\n    rules:\n      - record: {metric_name}\n        expr: {query}\n        labels:\n          source: loki-mcp\n"
        )
    };

    Ok(json!({
        "rule_type": rule_type,
        "metric_name": metric_name,
        "description": description,
        "rule_yaml": yaml,
    }))
}

fn extract_selector(query: &str) -> Option<String> {
    let start = query.find('{')?;
    let end = query[start..].find('}')? + start;

    Some(query[start..=end].to_string())
}

fn extract_pipeline_stages(query: &str) -> Vec<String> {
    let mut stages = Vec::new();

    for segment in query.split('|').skip(1) {
        let trimmed = segment.trim();
        if !trimmed.is_empty() {
            stages.push(trimmed.to_string());
        }
    }

    stages
}

fn extract_aggregation(query: &str) -> Option<String> {
    let normalized = query.trim_start();
    for name in [
        "count_over_time",
        "rate",
        "bytes_over_time",
        "bytes_rate",
        "sum",
        "avg",
        "max",
        "min",
    ] {
        if normalized.starts_with(name) {
            return Some(name.to_string());
        }
    }

    None
}
